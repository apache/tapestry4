Chapter
9
Complex Forms and Output
T
apestry includes a number of components designed to simplify interactions with the client, 
especially when handling forms.
In this chapter, we'll build a survey-taking application that collects information from the user, 
stores it in an in-memory database, and produces tabular results summarizing what has been 
entered.
We'll see how to validate input from the client, how to create radio groups and pop-up selections 
and how to organize information for display.
The application has three main screens; the first is a home page:
 
The second page is for entering survey data:
 
The last page is used to present results collected from many surveys:
 
In addition, we are re-using the Border component from the previous chapter.
The application does not use an actual database; the survey information is stored in memory (the 
amount of work to set up a JDBC database is beyond the scope of this tutorial).  
The source code for this chapter is in the tutorial.survey package.
Survey
At the root of this application is an object that represents a survey taken by a user. We want to 
collect the name (which is optional), the sex and the race, the age and lastly, which pets the survey 
taker prefers.
Survey.java
package tutorial.survey;

import java.util.*;
import com.primix.tapestry.*;
import java.io.*;

public class Survey implements Serializable, Cloneable
{
	private Object primaryKey;
	private String name;
	private int age = 0;
	private Sex sex = Sex.MALE;
	private Race race = Race.CAUCASIAN;
	
	private boolean likesDogs = true;
	private boolean likesCats;
	private boolean likesFerrits;
	private boolean likesTurnips;
	
	public Object getPrimaryKey()
	{
		return primaryKey;
	}
	
	public void setPrimaryKey(Object value)
	{
		primaryKey = value;
	}
	
	public String getName()
	{
		return name;
	}
	
	public void setName(String value)
	{
		name = value;
	}
	
	public int getAge()
	{
		return age;
	}
	
	public void setAge(int value)
	{
		age = value;
	}
 	
	public void setSex(Sex value)
	{
		sex = value;
	}
	
	public Sex getSex()
	{
		return sex;
	}
	
	public void setRace(Race value)
	{
		race = value;
	}
	
	public Race getRace()
	{
		return race;
	}
	
	public boolean getLikesCats()
	{
		return likesCats;
	}

	public void setLikesCats(boolean value)
	{
		likesCats = value;
	}
	
	public boolean getLikesDogs()
	{
		return likesDogs;
	}
	
	public void setLikesDogs(boolean value)
	{
		likesDogs = value;
	}
	
	public boolean getLikesFerrits()
	{
		return likesFerrits;
	}
	
	public void setLikesFerrits(boolean value)
	{
		likesFerrits = value;
	}
	
	public boolean getLikesTurnips()
	{
		return likesTurnips;
	}
	
	public void setLikesTurnips(boolean value)
	{
		likesTurnips = value;
	}
	
	/**
	 *  Validates that the survey is acceptible; throws an {@link 
IllegalArgumentException}
	 *  if not valid.
	 *
	 */
	 
	public void validate()
	throws IllegalArgumentException
	{
		if (race == null)
			throw new IllegalArgumentException("Race must be 
specified.");
		
		if (sex == null)
			throw new IllegalArgumentException("Sex must be 
specified.");
			
		if (age < 1)
			throw new IllegalArgumentException("Age must be at least 
one.");
	}	
	
	public Object clone()
	{
		try
		{
			return super.clone(); 
		}
		catch (CloneNotSupportedException e)
		{
			return null;
		}
	}
}
 
The race and sex properties are defined in terms of the Race and Sex classes, which are derived 
from com.primix.foundation.Enum.  Enum classes act like C enum types; a specific number of 
pre-defined values are declared by the class (as static final constants of the class).
Race.java
package tutorial.survey;

import com.primix.foundation.Enum;

/**
 *  An enumeration of different races.
 *
 */
 
public class Race extends Enum
{
	public static final Race CAUCASIAN = new Race("CAUCASIAN");
	public static final Race AFRICAN = new Race("AFRICAN");
	public static final Race ASIAN = new Race("ASIAN");
	public static final Race INUIT = new Race("INUIT");
	public static final Race MARTIAN = new Race("MARTIAN");

	private Race(String enumerationId)
	{
		super(enumerationId);
	}

	private Object readResolve()
	{
		return getSingleton();
	}

}
 
This is better than using String or int constants because of type safety; the Java compiler will 
notice if you pass Race.INUIT as a parameter that expects an instance of Sex ... if they were both 
encoded as numbers, the compiler wouldn't know that there was a programming error.
SurveyDatabase
The SurveyDatabase class is a mockup of a database for storing Surveys, it has methods such as 
addSurvey() and getAllSurveys().  To emulate a database, it even allocates primary keys for 
surveys.  Additionally, when surveys are added to the database, they are copied and when surveys 
are retrieved from the database, they are copied (that is, modifying a Survey instance after adding 
it to, or retrieving it from, the database doesn't affect the persistently stored Surveys within the 
database ... just as if they were in external storage).
SurveyEngine
The database is accessed via the SurveyApplication object.
SurveyEngine.java (excerpt)
	private transient SurveyDatabase database;

	public SurveyDatabase getDatabase()
	{
		return database;
	}
	
	protected void setupForRequest(RequestContext context)
	{
		super.setupForRequest(context);
		
		if (database == null)
		{
			String name = "Survey.database";
			ServletContext servletContext;
			
			servletContext = 
context.getServlet().getServletContext();
			
			database = 
(SurveyDatabase)servletContext.getAttribute(name);
			
			if (database == null)
			{
				database = new SurveyDatabase();
				servletContext.setAttribute(name, database);
			}
		}
	}

 
The SurveyDatabase instance is stored as a named attribute of the ServletContext, a shared space 
available to all sessions.
SurveyPage
The SurveyPage is where survey information is collected.  It initially creates an Survey instance as 
a persistent page property.  It uses Form and a number of other components to edit the survey.
When the survey is complete and valid, it is added to the database and the results page is used as 
an acknowledgment.
The SurveyPage also demonstrates how to validate data from a TextField component, and how to 
display validation errors.  If invalid data is enterred, then the user is notified (after submitting the 
form):
  
 
The HTML template for the page is relatively short.  All the interesting stuff comes later, in the 
specification and the Java class.
SurveyPage.html
<jwc id="border">

<jwc id="ifError">
<table border=1>
<tr>
<td bgcolor=red>
<font style=bold color=white>
<jwc id="insertError"/>
</font> </tr> </tr> </table>
</jwc>

<jwc id="surveyForm">

<table border=0>

<tr valign=top> <th>Name</th>
	 <td colspan=3><jwc id="inputName"/></td></tr>

<tr valign=top>  <th>Age</th>
	 <td colspan=3><jwc id="inputAge"/></td></tr>

<tr valign=top> <th>Sex</th>
	  <td> <jwc id="inputSex"/>  
	  </td>

	  <th>Race</th>

      <td><jwc id="inputRace"/>
      </td> </tr>

<tr valign=top> <th>Favorite Pets</th>
	<td colspan=3>
	<jwc id="inputCats"/> Cats
<br><jwc id="inputDogs"/> Dogs
<br><jwc id="inputFerrits"/> Ferrits
<br><jwc id="inputTurnips"/> Turnips</td> </tr>
<tr>
<td></td>
<td colspan=3><input type=submit value="Submit"></td> </tr>
</table>

</jwc>
</jwc>
 
Most of this page is wrapped by the surveyForm component which is of type Form.  The form 
contains two text fields (nameField and ageField), a group of radio buttons (ageSelect) and a pop-
up list (raceSelect), and a number of check boxes (cats, dogs, ferrits and turnips).
Most of these components are pretty straight forward:  nameField and ageField are setting String 
properties, and the check boxes are setting boolean properties.  The two other components, 
raceSelect and ageSelect, are more interesting.
Both of these are of type PropertySelection; they are used for setting a specific property of some 
object to one of a number of possible values.
The PropertySelection component has some difficult tasks:  It must know what the possible 
values are (including the correct order).  It must also know how to display the values (that is, what 
labels to use on the radio buttons or in the pop up).
This information is provided by a model (an object that implements the interface 
com.primix.tapestry.components.html.form.IPropertySelectionModel), an object 
that exists just to provide this information to a PropertySelection component.
There's a secondary question with PropertySelection: how the component is rendered.  By default, 
it creates a pop-up list, but this can be changed by providing an alternate renderer (using the 
component's renderer parameter).  In our case, we used a secondary, radio-button renderer.  
Applications can also create their own renders, if they need to do something special with fonts, 
styles or images.
First, let's review the specification for the SurveyPage:
SurveyPage.jwc
<?xml version="1.0"?>
<!DOCTYPE specification PUBLIC "-//Primix Solutions//Tapestry Specification 
1.0//EN"
	"http://tapestry.sourceforge.net/dtd/Tapestry_1_0.dtd">
<specification>
	<class>tutorial.survey.SurveyPage</class>
	<components>
		<component>
			<id>border</id>
			<type>Border</type>
			<bindings>
				<static-binding>
					<name>title</name>
					<value>Survey</value>
				</static-binding>
				<binding>
					<name>pages</name>
					<property-
path>application.pageNames</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>ifError</id>
			<type>Conditional</type>
			<bindings>
				<binding>
					<name>condition</name>
					<property-path>error</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>insertError</id>
			<type>Insert</type>
			<bindings>
				<binding>
					<name>value</name>
					<property-path>error</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>surveyForm</id>
			<type>Form</type>
			<bindings>
				<binding>
					<name>listener</name>
					<property-path>formListener</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputName</id>
			<type>TextField</type>
			<bindings>
				<static-binding>
					<name>displayWidth</name>
					<value>30</value>
				</static-binding>
				<static-binding>
					<name>maximumWidth</name>
					<value>100</value>
				</static-binding>
				<binding>
					<name>text</name>
					<property-path>survey.name</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputAge</id>
			<type>TextField</type>
			<bindings>
				<static-binding>
					<name>displayWidth</name>
					<value>4</value>
				</static-binding>
				<static-binding>
					<name>maximumWidth</name>
					<value>4</value>
				</static-binding>
				<binding>
					<name>text</name>
					<property-path>age</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputSex</id>
			<type>PropertySelection</type>
			<bindings>
				<binding>
					<name>value</name>
					<property-path>survey.sex</property-path>
				</binding>
				<binding>
					<name>model</name>
					<property-path>sexModel</property-path>
				</binding>
				<binding>
					<name>renderer</name>
					<property-
path>components.inputSex.defaultRadioRenderer</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputRace</id>
			<type>PropertySelection</type>
			<bindings>
				<binding>
					<name>value</name>
					<property-path>survey.race</property-path>
				</binding>
				<binding>
					<name>model</name>
					<property-path>raceModel</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputCats</id>
			<type>Checkbox</type>
			<bindings>
				<binding>
					<name>selected</name>
					<property-path>survey.likesCats</property-
path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputDogs</id>
			<type>Checkbox</type>
			<bindings>
				<binding>
					<name>selected</name>
					<property-path>survey.likesDogs</property-
path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputFerrits</id>
			<type>Checkbox</type>
			<bindings>
				<binding>
					<name>selected</name>
					<property-
path>survey.likesFerrits</property-path>
				</binding>
			</bindings>
		</component>
		<component>
			<id>inputTurnips</id>
			<type>Checkbox</type>
			<bindings>
				<binding>
					<name>selected</name>
					<property-
path>survey.likesTurnips</property-path>
				</binding>
			</bindings>
		</component>
	</components>
</specification>
 
Several of the components, such as inputName and inputTurnips, modify properties of the survey 
directly.  The SurveyPage class has a survey property, which allows for property paths like 
survey.name and survey.likesTurnips.
The age field is more complicated, since it must be converted from a String to an int before being 
assigned to the survey's age property ... and the page must check that the user enterred a valid 
number as well.
Finally, the SurveyPage class shows how all the details fit together:
SurveyPage.java
package tutorial.survey;

import com.primix.tapestry.*;
import com.primix.tapestry.components.html.form.*;
import java.util.*;

public class SurveyPage extends BasePage
{
	private Survey survey;
	private String error;
	private String age;
	private IPropertySelectionModel sexModel;
	private IPropertySelectionModel raceModel;
	
	public IPropertySelectionModel getRaceModel()
	{
		if (raceModel == null)
			raceModel = new EnumPropertySelectionModel(
				new Race[] 
				{
					Race.CAUCASIAN, Race.AFRICAN, Race.ASIAN, 
Race.INUIT, Race.MARTIAN
				},  getBundle("tutorial.survey.SurveyStrings"), 
"Race");
				
		return raceModel;
	}
		
	public IPropertySelectionModel getSexModel()
	{
		if (sexModel == null)
			sexModel = new EnumPropertySelectionModel(
				new Sex[] 
				{
					Sex.MALE, Sex.FEMALE, Sex.TRANSGENDER, 
Sex.ASEXUAL	
				},  getBundle("tutorial.survey.SurveyStrings"), 
"Sex");
				
		return sexModel;
	}	
	
    private ResourceBundle getBundle(String resourceName)
    {
        return ResourceBundle.getBundle(resourceName, getLocale());
    }
		
	public IActionListener getFormListener()
	{
		return new IActionListener()
		{
			public void actionTriggered(IComponent component, 
IRequestCycle cycle)
			{
				try
				{
					survey.setAge(Integer.parseInt(age));
					
					survey.validate();
				}
				catch (NumberFormatException e)
				{
					// NumberFormatException doesn't provide 
any useful data
					
					setError("Value entered for age is not a 
number.");
					return;
				}
				catch (Exception e)
				{
					setError(e.getMessage());
					return;
				}
				
				// Survey is OK, add it to the database.
				
			
	((SurveyApplication)getApplication()).getDatabase().addSurvey(survey
);
				
				setSurvey(null);	
				
				// Jump to the results page to show the totals.
				
				cycle.setPage("Results");
			}	
		};
	}
		
	public Survey getSurvey()
	{
		if (survey == null)
			setSurvey(new Survey());
				
		return survey;
	}
	
	public void setSurvey(Survey value)
	{
		survey = value;
		fireObservedChange("survey", survey);
	}
	
	public void detach()
	{
		super.detach();
		
		survey = null;
		error = null;
		age = null;
		
		// We keep the models, since they are stateless
	}
	
	public void setError(String value)
	{
		error = value;
	}
	
	public String getError()
	{
		return error;
	}
	
	public String getAge()
	{
		int ageValue;
		
		if (age == null)
			{
			ageValue = getSurvey().getAge();
			
			if (ageValue == 0)
				age = "";
			else 
				age = Integer.toString(ageValue);
		}	
		
		return age;	
	}
	
	public void setAge(String value)
	{
		age = value;
	}
} 

 
A few notes.  First, the raceModel and sexModel properties are created on-the-fly as needed.  The 
EnumPropertySelectionModel is a provided class that simplifies using a PropertySelection 
component to set an Enum-typed property.  We provide the list of possible values, and the 
information needed to extract the corresponding labels from a properties file, in this case, 
SurveyStrings.properties:
SurveyStrings.properties
Race.CAUCASIAN=Caucasian
Race.AFRICAN=African
Race.ASIAN=Asian
Race.INUIT=Inuit
Race.MARTIAN=Martian

Sex.ASEXUAL=Non-Sexual
Sex.MALE=Male
Sex.FEMALE=Female
Sex.TRANSGENDER=Transgender
 
Only survey is a persistent page property.  The error property is transient (it is set to null at the 
end of the request cycle).  The error property doesn't need to be persistent ... it is generated during 
a request cycle and is not used on a subsequent request cycle (because the survey will be re-
validated).
Likewise, the age property isn't page persistent.  If an invalid value is submitted, then its value will 
come up from the HttpServletRequest parameter and be plugged into the age property of the 
page.  If validation of the survey fails, then the SurveyPage will be used to render the HTML 
response, and the invalid age value will still be there.
In the detachFromApplication() method, the survey, error and age properties are properly 
cleared.  The raceModel and ageModel properties are not ... they are stateless and leaving them in 
place saves the trouble of creating identical objects later.
Results
Displaying results is broken up into two parts.  In the first part, the database is queries for all 
surveys, and totals in a number of categories are prepared.
In the second part, those interrum results are incorporated into the HTML response page.
Results.html
<jwc id="border">

Summary of <jwc id="insertSurveyCount"/> surveys:

	<jwc id="e-results">
		<jwc id="ifFirst">
<table border=0>
	<tr bgcolor=black>
		<th><font color=white>Result</font></th>
		<th><font color=white>Count</font></th>
		<th><font color=white>%</font></th>
	</tr>
		</jwc>
		<jwc id="results-row">
		<td>
			<jwc id="insertResult"/>
		</td>
		<td>
			<jwc id="insertCount"/>
		</td>
		<td align=right>
			<jwc id="insertPercent"/>
		</td>
		</jwc>
		<jwc id="ifLast">
</table>
		</jwc>
	</jwc>

</jwc>
 
This template shows how those results will be provided to a Foreach component (e-results) that 
will iterate through them, and use a set of three Insert components.  The ifFirst and ifLast 
components are used to generate the start and end of the HTML table (if the results are empty 
then the table doesn't get rendered at all).
The results-row component will take the place of the normal <TR> element in a table.  It exists 
to vary the HTML bgcolor attribute, alternating between white and grey backgrounds for 
readability.
Results.jwc
<?xml version="1.0"?>
<!DOCTYPE specification PUBLIC 
"-//Primix Solutions//Tapestry Specification 1.0//EN"
	"http://tapestry.sourceforge.net/dtd/Tapestry_1_0.dtd">
	
<specification>
	<class>tutorial.survey.Results</class>
		
	<components>
		<component>
			<id>border</id>
			<type>Border</type>
			
			<bindings>
				<static-binding>
					<name>title</name>
					<value>Results</value>
				</static-binding>

				<binding>
					<name>pages</name>
					<property-
path>application.pageNames</property-path>
				</binding>
			</bindings>
		</component>

		<component>
			<id>insertSurveyCount</id>
			<type>Insert</type>

			<bindings>
				<binding>
					<name>value</name>
					<property-
path>database.surveyCount</property-path>
				</binding>
			</bindings>
		</component>

		<!-- The results is a List of Maps.  -->

		<component>
			<id>e-results</id>
			<type>Foreach</type>

			<bindings>
				<binding>
					<name>source</name>
					<property-path>results</property-path>
				</binding>
			</bindings>
		</component>

		<component>
			<id>ifFirst</id>
			<type>Conditional</type>

			<bindings>
				<binding>
					<name>condition</name>
					<property-path>components.e-
results.first</property-path>
				</binding>
			</bindings>
		</component>

		<!-- This stands in for the TR element, but handles the 
bgcolor. -->

		<component>
			<id>results-row</id>
			<type>Any</type>

			<bindings>
				<static-binding>
					<name>element</name>
					<value>tr</value>
				</static-binding>

				<binding>
					<name>bgcolor</name>
					<property-path>rowColor</property-path>
				</binding>
			</bindings>
		</component>

		<component>
			<id>insertResult</id>
			<type>Insert</type>

			<bindings>
				<binding>
					<name>value</name>
					<property-path>components.e-
results.value.name</property-path>
				</binding>
			</bindings>
		</component>


		<component>
			<id>insertCount</id>
			<type>Insert</type>

			<bindings>
				<binding>
					<name>value</name>
					<property-path>components.e-
results.value.count</property-path>
				</binding>
			</bindings>
		</component>

		<component>
			<id>insertPercent</id>
			<type>Insert</type>

			<bindings>
				<binding>
					<name>value</name>
					<property-path>components.e-
results.value.percent</property-path>
				</binding>
			</bindings>
		</component>

		<component>
			<id>ifLast</id>
			<type>Conditional</type>

			<bindings>
				<binding>
					<name>condition</name>
					<property-path>components.e-
results.last</property-path>
				</binding>
			</bindings>
		</component>

	</components>

</specification>
 
The presentation relies on the Java class providing a results property.  This property is a List of 
Maps.  Each Map has three keys:  name, count and percent.  The rest of the logic is simply to break 
apart this List into Maps (as property-path components.e-results.value), and to pull out the values 
for the three keys.
Creating this results property consumes the bulk of the class:
Results.java
package tutorial.survey;

import com.primix.tapestry.*;
import java.util.*;
import java.text.*;
import java.awt.Color;

public class Results extends BasePage
{
	private SurveyDatabase surveyDatabase;
	private boolean oddRow = false;
	private NumberFormat percentFormat;
		
	public SurveyDatabase getDatabase()
	{
		if (surveyDatabase == null)
		{
			SurveyApplication surveyApplication;
			
			surveyApplication = (SurveyApplication)application;
			
			surveyDatabase = surveyApplication.getDatabase();
		}
		
		return surveyDatabase;
	}
	
	public void detach()
	{
		super.detach();
		
		surveyDatabase = null;
		oddRow = false;
	}
	
	public String getRowColor()
	{
		Color color;
		String result;
		
		if (oddRow)
			color = Color.lightGray;
		else
			color = Color.white;	
			
		result = RequestContext.encodeColor(color);
		
		oddRow = !oddRow;
		
		return result;
	}
	
	public List getResults()
	{
		int raceAfrican = 0;
		int raceAsian = 0;
		int raceCaucasian = 0;
		int raceInuit = 0;
		int raceMartian = 0;
		int sexAsexual = 0;
		int sexFemale  = 0;
		int sexMale = 0;
		int sexTransgender = 0;
		int likesCats = 0;
		int likesDogs = 0;
		int likesFerrits = 0;
		int likesTurnips = 0;
		int ageToTeen = 0; // 1 - 18
		int ageEarlyAdult = 0; // 19 - 28
		int ageToMiddle  = 0; // 29 - 35
		int ageMiddle = 0; // 36 - 49
		int ageOlder = 0; // 50 - 64
		int ageRetire = 0; // 65 - 80
		int ageOld = 0; // 81 - 100
		Survey[] surveys;
		Survey survey;
		List result;
		Race race;
		Sex sex;
		int count;
		int i;
		int age;
		
		surveys = getDatabase().getAllSurveys();
		if (surveys == null ||
			surveys.length == 0)
			return null;

		count = surveys.length;
		for (i = 0; i < count; i++)
		{
			survey = surveys[i];
			
			race = survey.getRace();
			if (race == Race.AFRICAN)
				raceAfrican++;
			
			if (race == Race.ASIAN)
				raceAsian++;
			
			if (race == Race.CAUCASIAN)
				raceCaucasian++;
				
			if (race == Race.INUIT)
				raceInuit++;
				
			if (race == Race.MARTIAN)
				raceMartian++;
				
			sex = survey.getSex();
			if (sex == Sex.MALE)
				sexMale++;
				
			if (sex == Sex.FEMALE)
				sexFemale++;
				
			if (sex == Sex.TRANSGENDER)
				sexTransgender++;
				
			if (sex == Sex.ASEXUAL)
				sexAsexual++;
			
			if (survey.getLikesCats())
				likesCats++;
				
			if (survey.getLikesDogs())
				likesDogs++;
				
			if (survey.getLikesFerrits())
				likesFerrits++;
				
			if (survey.getLikesTurnips())
				likesTurnips++;	
			
			age = survey.getAge();
			
			if (age < 19)
				ageToTeen++;
			
			if (age >= 19 && age <= 28)
				ageEarlyAdult++;
				
			if (age >= 29 && age <= 35)
				ageToMiddle++;
				
			if (age >= 36 && age <= 49)
				ageMiddle++;
			
			if (age >= 50 && age <= 64)
				ageOlder++;
			
			if (age >= 65 && age <= 80)
				ageRetire++;
			
			if (age >= 81)
				ageOld++;	
					
		}
		
		result = new ArrayList();
		
		result.add(buildResult("Sex : Male", sexMale, count));
		result.add(buildResult("Sex : Female", sexFemale, count));
		result.add(buildResult("Sex : Transgender", sexTransgender, 
count));
		result.add(buildResult("Sex : Asexual", sexAsexual, count));
		
		result.add(buildResult("Race : Caucasian", raceCaucasian, 
count));
		result.add(buildResult("Race : African", raceAfrican, count));
		result.add(buildResult("Race : Asian", raceAsian, count));
		result.add(buildResult("Race : Inuit", raceInuit, count));
		result.add(buildResult("Race : Martian", raceMartian, count));
		
		result.add(buildResult("Age: to 18", ageToTeen, count));
		result.add(buildResult("Age: 19 - 28", ageEarlyAdult, count));
		result.add(buildResult("Age: 29 - 35", ageToMiddle, count));
		result.add(buildResult("Age: 36 - 49", ageMiddle, count));
		result.add(buildResult("Age: 50 - 64", ageOlder, count));
		result.add(buildResult("Age: 65 - 80", ageRetire, count));
		result.add(buildResult("Age: 80 and up", ageOld, count));
				
		result.add(buildResult("Likes cats", likesCats, count));
		result.add(buildResult("Likes dogs", likesDogs, count));
		result.add(buildResult("Likes ferrits", likesFerrits, count));
		result.add(buildResult("Likes turnips", likesTurnips, count));
			
		return result;
	}
	
	private Map buildResult(String name, int count, int total)
	{
		Map result;
		
		result = new HashMap(3);
		result.put("name", name);
		result.put("count", new Integer(count));
		
		if (percentFormat == null)
			percentFormat = 
NumberFormat.getPercentInstance(getLocale());
		
		result.put("percent", percentFormat.format((double)count / 
(double)total));	
		
		return result;
	}
		
}
Chapter
10
Localization
O
ne of the most powerful and useful features of the Tapestry framework is the way in which it 
assists with localization of a web application.  This is normally an ugly area in web applications, 
with tremendous amounts of ad-hoc coding necessary.
Because Tapestry does such a strong job of seperating the presentation of a component (its 
HTML template) from its control logic (its specification and Java class) it becomes easy for it to 
perform localization automatically.  It's as simple as providing additional localized HTML 
templates for the component, and letting the framework select the proper one.
However, the static text of an application, provided by the HTML templates, is not all.  
Applications also have assets (images, stylesheets and the like) that must also be localized … that 
fancy button labeled "Search" is fine for your English clients, but your French cliensts will require 
a similar button labeled "Recherche".
Again, the framework assists, because it can look for localized versions of the assets as it runs.
The locale application demostrates this.  It is a very simply application that demonstrates changing 
the locale of a running application.
The Home page of the application allows you to select a new language for the application:
 
Selecting "German" from the list and clicking the "Change" button brings you to a new page that 
acknowledges your selection :
 
Clicking the button (it's labeled "Select Another" in German) returns you to the Home page to 
select a new language:
 
The neat thing here is that the Home page has been localized into German as well; it shows 
equivalent German text, the options in the popup list are in German, and the "Change" button 
has been replaced with a German equivalent.
Home Page
The Home page consists of a single component specification, four versions of the HTML 
template and four image assets.
Home.jwc (excerpt)
	.
	.
	.
	<component>
		<id>inputLocale</id>
		<type>PropertySelection</type>
		<bindings>
			<binding>
				<name>value</name>
				<property-path>selectedLocale</property-path>
			</binding>
			<binding>
				<name>model</name>
				<property-path>localeModel</property-path>
			</binding>
		</bindings>
	</component>
	<component>
		<id>changeButton</id>
		<type>ImageButton</type>
		<bindings>
			<binding>
				<name>image</name>
				<property-path>assets.change-button</property-
path>
			</binding>
		</bindings>
	</component>
</components>
<assets>
	<private-asset>
		<name>change-button</name>
		<resource-path>/tutorial/locale/Change.gif</resource-path>
	</private-asset>
</assets>
 
The changeButton component is an ImageButton, a Tapestry version of an <input 
type="image"> HTML form element.  We provide it with an image, and asset that will be used as 
the src attribute of the HTML element.
The property path assets.change-button is a convienience; each component may have a number 
of named assets and has an assets property that is a Map of those assets.
We also must define the asset, naming it change-button.  We declare it as a private asset, an asset 
that is not directly visible to the servlet container, but is instead packaged with the Java classes in a 
JAR or in the WEB-INF/classes directory of a WAR.
In fact, there are four files in that directory, named Change.gif, Change_de.gif, Change_fr.gif and 
Change_it.gif.  Those suffixes (_de, _fr, etc.) identify the locale for which the image is appropriate.  
More information on those suffixes is available from the java.util.Locale documentation.
When Tapestry is rendering the page, it knows what locale is currently selected for the application 
(it's a property of the engine object) and chooses the correct file based on that.
Along with the four images, there are four HTML templates.
Home.html
<jwc id="border">

This tutorial demonstration how to dynamically change the locale
for the running application.

<p>
Select a new locale:

<jwc id="form">
	<jwc id="inputLocale"/>
	<jwc id="changeButton"/>
</jwc>

</jwc>
 
The alternate locale versions are named in the same pattern as the image asset files.
Home_de.html
<jwc id="border">

Diese Referentendemonstration, wie man dynamisch
das locale f&#252;r die laufende Anwendung &#228;ndert.

<p>
W&#228;hlen Sie ein neues locale aus:

<jwc id="form">
	<jwc id="inputLocale"/>
	<jwc id="changeButton"/>
</jwc>

</jwc>
 
The ids of components are consistent regardless of the locale used … these are internal ids (the 
equivalent of variable names) and are not shown to the end user.  In addition, there's only one 
specification file and the ids here must match the ids in the specification.
The only real different is the static text which, here, is in German.
Again, when Tapestry is rendering the page, it first chooses the correct localized HTML template.  
When it is rendering the changeButton component, it finds the correct localized file.
What if there isn't a localization of a template or file?  Tapestry will use the more general file.  For 
instance, if we somehow managed to convince the application that we spoke Spanish we would 
see mostly English text since we didn't provide Spanish localized templates or assets.
The Java code for the Home page is simple enough that we can largely skip it.  The only 
interesting parts are providing a property selection model for the inputLocale component and 
responding when the form is submitted:
Home.java (excerpt)
    public void actionTriggered(IComponent component, IRequestCycle cycle)
    throws RequestCycleException
    {
        getEngine().setLocale(selectedLocale);

        cycle.setPage("Change");
    }

Change page
After the use selects a language, the application switches to the  Change page for a response, 
which includes a link back to the Home page (as a localized image button).
Change.html
<jwc id="border">

Congratulations, you've changed the locale to <jwc id="insertLocaleName"/>.

<p><jwc id="home"><jwc id="chooseAgainImage"/></jwc>

</jwc>
 
This template combines with the specification that identifies the images.
Change.jwc (excerpt)
	.
	.
	.
	<component>
		<id>chooseAgainImage</id>
		<type>Image</type>
		<bindings>
			<binding>
				<name>image</name>
				<property-path>assets.choose-again</property-path>
			</binding>
		</bindings>
	</component>
</components>
<assets>
	<context-asset>
		<name>choose-again</name>
		<path>/images/locale/ChooseAgain.gif</path>
	</context-asset>
</assets>
 
This is similar to the previous example, in that we've provided four versions of the 
ChooseAgain.gif image asset.
However, we've put the images in a different place.  This time, the asset is a context asset, an asset 
that is visible to the servlet container.  In this example, the file ChooseAgain.gif is located in the 
/images/locale directory of the WAR.  Tapestry makes sure that the correct prefix (/tutorial) is 
prepended to the path when the HTML is rendered.
Context assets are the most common assets used.  Private assets (as used on the Home page) are 
used mostly when creating libraries of components for reuse.  When building an application that 
stands on its own, context assets are easier and more efficient.
As with the Home page, there are multiple localizations of the Change page.
Change_de.html
<jwc id="border">


Gl&#252;ckw&#252;nsche, haben Sie ge&#228;ndert das locale zu <jwc 
id="insertLocaleName"/>.

<p><jwc id="home"><jwc id="chooseAgainImage"/></jwc>

</jwc>
 
As we saw previously, the components in the HTML template are the same, just the static HTML 
has changed.
Other Options for Localization
In some cases, different localizations of the a component will be very similar, perhaps having only 
one or two small snippets of text that is different.
In those cases, it may be easier on the developer to not localize the HTML template, but to 
replace the variant text with an Insert component.
The page can read a localized Strings file (a .properties file) to get appropriate localized text.  This 
saves the bother of maintaining multiple HTML templates.
All components on a page share the single locale for the page, but each performs its own search 
for its HTML template.  This means that some components may not have to be localized, if they 
never contain any static HTML text.  This is sometimes the case for reusable components, even 
navigational borders.



Chapter
11
Further Study
T
he preceding chapters cover many of the basic aspects of Tapestry.  You should be comfortable 
with basic Tapestry concepts:
?	Seperation of presentation, business and control logic
?	Use of JavaBeans properties as the source of dynamic data
?	How bindings access JavaBeans properties to provide data to components
?	How components wrap each other, allowing for the creation of very complicated 
components through aggregation.
?	Different types of page properties (transient, dynamic, persistent)
Tapestry is capable of quite a bit more.  Also available within the Tapestry Examples package 
(along with the tutorial code and this document) is the Primix Virtual Library application (Vlib).
Vlib is a full-blown J2EE application, that makes use of Tapestry as its front end, and a set of 
session and entity Enterprise JavaBeans as its back end.
Vlib also demonstrates some of the other aspects of developing a Tapestry application.  It shows 
how to create pages that are bookmarkable (meaning that their URL includes enough information 
to reconstruct them in a subsequent session).  It shows how to handle logging in to an application, 
and how to protect pages from being accessed until the user is logged in.  It has many specialized 
reusable components for creating links to pages about books and people.
  The actual release numbers will change.  This document was prepared for Tapestry-0-2-8.
  Specifications and templates are generally read just once, then left in memory for susbsequent use.
  Direct is kind of an abbreviation for DirectAction.  There is another component, Action, that was written first and also 
creates a hyperlink on the page.  This is one of those naming connundrums that has managed to get itself entrenched in 
Tapestry and is best to accept in the style of a magic incantation.
  Translations were done using Bablefish and are probably laughably bad to someone who actually speaks the language.
3





TAPESTRY TUTORIAL
84


