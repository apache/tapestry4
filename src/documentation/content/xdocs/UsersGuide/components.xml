<?xml version="1.0" encoding="utf-8"?>
<!--
   Copyright 2004 The Apache Software Foundation
  
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
  
       http://www.apache.org/licenses/LICENSE-2.0
  
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V1.2//EN" "./dtd/document-v12.dtd"
[
	<!ENTITY projectroot '../'>
	<!ENTITY % links.ent SYSTEM "../links.ent">
  <!ENTITY % common.ent SYSTEM "common.ent">
	%links.ent;
  %common.ent;
]>
<document>
  <header>
	<title>Creating Tapestry components</title>
  </header>

<body>
	
<p>
Tapestry is a component based web application framework; components, objects which implement
the &IComponent; interface, are the fundamental building blocks of Tapestry.  Additional objects,
such as the the engine, &IMarkupWriter; and the request cycle are infrastructure. The following figure
identifies the core Tapestry classes and interfaces.
</p>	

<figure alt="Core Tapestry Classes and Interfaces" src="&imageroot;/core-classes.png"/>
	
<p>
Tapestry components can be simple or complex. They can be specific to a
single application or completely generic. They can be part of an application,
or they can be packaged into
a <link href="#components.libraries">component library</link>.
</p>

<p>
All the techniques used with pages work with components as well ... pages are a specialized kind
of Tapestry component. This includes
<link href="state.html#state.page-properties">specified properties</link>
	 (including persistent properties)
and &listener-method;s.
</p>

<p>
Components fit into the overall page rendering process because they implement the &IRender; interface.
Components that inherit from &BaseComponent; will use an HTML template.  Components that inherit
from &AbstractComponent; will render output in Java code, by implementing method
<code>renderComponent()</code>.
</p>

<p>
The components provided with the framework are not special in any way: they don't have access to
any special APIs or perform any special down-casts. Anything a framework component can do, can be done by
your own components.	
</p>


<section id="components.spec">
	<title>Component Specifications</title>
	
<p>
Every component has a component specification, a file ending with a .jwc extension, whose
root element is &spec.component-specification;.
</p>

<p>
Each component's specification defines the basic characteristics of the component:
</p>

<ul>
	<li>
		The Java class for the component (which defaults to &BaseComponent;)	
	</li>	
	<li>
		Whether the component uses its body, or discards it (the allow-body attribute,
			which defaults to yes)
	</li>
	<li>
		<p>
			The name, type and other information for each <em>formal</em>
			parameter.
		</p>	
	</li>
	<li>
		<p>
			Whether the component allows informal parameters or discards them
			(the allow-informal-parameters attribute, which defaults to 
			yes)
		</p>	
	</li>
	<li>
		<p>
		The names of any <em>reserved parameters</em> which may <em>not</em>
		be used as informal parameters.
		</p>	
	</li>
</ul>	


<p>
Beyond those additions, a component specification is otherwise the same as a &spec.page-specification;.
</p>

<p>
When a component is referenced in an HTML template (using the @<em>Type</em>
syntax), or in a specification (as the type attribute of
a &spec.component; element), Tapestry must locate and parse the component's specification (this is only done once, with the
result cached for later).
</p>

<p>
Tapestry searches for components in the following places:</p>

<ul>
	<li>
		As specified in a &spec.component-type; element (within the application specification).
	</li>	
	<li>
	In the same folder  as the 
			application specification, which is typically the WEB-INF folder.
	</li>
	<li>
		In the WEB-INF/<em>servlet-name</em> folder
		(<em>servlet-name</em> is the name of the Tapestry &ApplicationServlet;
		for the application).
	</li>
	<li>
			In the WEB-INF folder.
	</li>
	<li>
			In the root context directory.
	</li>
</ul>	


		<note>
			The second option,   WEB-INF/<em>servlet-name</em>, 
      exists to support the rare case of a single WAR file containing
			multiple Tapestry applications.
		</note>
    
<p>
Generally, the <em>correct</em>	 place is in the
WEB-INF folder.  <link href="#components.libraries">Components packaged into
	libraries</link> have a different (and simpler) search.
</p>
	

</section> <!-- components.spec -->

<section id="components.coding">
	<title>Coding components</title>
	
<p>
When creating a new component by subclassing &AbstractComponent;, you must write the
<code>renderComponent()</code>	 method. This method is invoked when the component's container (typically, but not always,
a page) invokes its own <code>renderBody()</code> method.
</p>

<source>
protected void renderComponent(&IMarkupWriter; writer, &IRequestCycle; cycle)
{
  . . .
}	
</source>

<p>
The &IMarkupWriter; object is used to produce output. It contains a number of <code>print()</code>	 methods
that output text (the method is overloaded for different types).  It also contains <code>printRaw()</code>
methods -- the difference being that <code>print()</code> uses a filter to convert certain characters
into HTML entities.  
</p>
	
	
<p>
&IMarkupWriter; also includes methods to simplify creating markup style output: that is, elements with attributes.	
</p>


<p>
For example, to create a &lt;a&gt; link:
	</p>
  
<source>
public void renderComponent(&IMarkupWriter; writer, &IRequestCycle; cycle)
{
  . . .
  
  writer.begin("a");
  writer.attribute("url", url);
  writer.attribute("class", styleClass);

  renderBody(writer, cycle);

  writer.end(); // close the &lt;a&gt;	
}
</source>

	
<p>
The <code>begin()</code>	 method renders an open tag (the &lt;a&gt;, in
this case). The <code>end()</code> method renders
the corresponding &lt;/a&gt;. As you can see, writing attributes into the tag
is equally simple.
</p>
	
	
<p>
The call to <code>renderBody()</code> is used to render <em>this</em> component's
body. A component doesn't have to render its body; the standard &Image; component doesn't render its
body (and its component specification indicates that it discards its body). The &Conditional; component
decides whether or not to render its body, and the
&Foreach; component may render its body multiple times.
</p>

<p>
A component that allows informal parameters can render those as well:
</p>

<source>
  writer.beginEmpty("img");
  writer.attribute("src", imageURL);
  renderInformalParameters(writer, cycle);
</source>


<p>
This example will add any informal parameters for the component
as additional attributes within the &lt;img&gt;	 element. These informal parameters
can be specified in the page's HTML template, or within the &spec.component; tag of the page's specification. Note the use
of the <code>beginEmpty()</code> method, for creating a start tag that is not balanced with an end tag (or
a call to the <code>end()</code> method).
</p>

</section> <!-- components.coding -->

<section id="components.parameters">
	<title>Component Parameters</title>
	
<p>
A Tapestry page consists of a number of components. These components communicate with, and coordinate with,
the page (and each other) via <em>parameters</em>.
</p>

<p>
A component parameter has a unique name and a type (a Java class, interface, or primitive type name).	
The &spec.parameter; component specification element is used to define formal component parameters.
</p>

<p>
In a traditional desktop application, components have <em>properties</em>. A controller may
set the properties of a component, but that's it: properties are write-and-forget.
</p>
	
<p>
The Tapestry model is a little more complex. A component's parameters are <em>bound</em>	
to properties of the enclosing page. The component is allowed to read its parameter, to access
the page property the parameter is bound to.  A component may also <em>update</em> its
parameter, to force a change to the bound page property.
</p>	

<p>
The vast majority of components simply read their parameters. Updating parameters is more rare; the most
common components that update their parameters are form control components such as &TextField; or &Checkbox;.	
</p>

<p>
Because bindings are often in the form of &OGNL; expressions, the property bound to a component parameter
may not directly be a property of the page ... using a property sequence allows great flexibility.	
</p>

<figure alt="Parameter Bindings" src="&imageroot;/parameter-bindings.png"/>

      <p>
Using &OGNL;, the &TextField; component's value parameter is bound
to the LineItem's quantity property, using
the OGNL expression lineItem.quantity, and the &Insert; component's
value parameter is bound to the Product's 
name property using the OGNL expression lineItem.product.name.
     </p>


<p>
Not all parameter bindings are writable. OGNL expressions may be writeable, if the expression
identifies a property that is itself writeable. Other types of bindings, such as message bindings
(the message: prefix), or literal bindings (no prefix) are read only.
</p>
	
<section id="components.parameters.bindings">
	<title>Using Bindings</title>
	
<p>
To understand how Tapestry parameters work, you must understand how the binding objects work (even
though, as we'll see, the binding objects are typically hidden). When a component needs access to
a bound parameter value, it will invoke the method <code>getObject()</code>	 on &IBinding;
</p>

      <figure alt="Reading a parameter" src="&imageroot;/read-binding.png"/>
      

      <p>
The <code>getObject()</code> method on &IBinding; will (if the binding is dynamic) evaluate the
OGNL expression (provided in the &spec.binding; specification element) to access a property of the
page. The result is that cast or otherwise coerced to a type useful to the component.
     </p>



<p>
Updating a parameter is the same way, except that the method is
<code>setObject()</code>. Most of the implementations of &IBinding; (those for literal strings
and localized messages), will throw an exception immediately, since they are invariant.
</p>

<figure alt="Updating a parameter" src="&imageroot;/write-binding.png"/>


      <p>
The <code>setObject()</code> method will use OGNL to update a page property.
     </p>


<p>
These flows are complicated by the fact that parameters may be optional; so not only do you need to acquire the
correct binding object (method <code>getBinding()</code> defined in &IComponent;), 
but your code must be prepared for that object to be null (if the parameter
is optional). 	
</p>

</section> <!-- components.parameters.bindings -->
		
<section id="components.parameters.connected">
	<title>Connected Parameter Properties</title>
	
<p>
Accessing and manipulating the &IBinding; objects is tedious, so Tapestry has an alternate approach. Parameters may
be represented as <em>connected parameter properties</em>	 that hide the existence of
the binding objects entirely. If you component needs to know the value bound to a parameter, it can
read the connected parameter property. If it wants to update the property bound to the parameter, the component
will update the connected parameter. This is a much more natural approach, but requires a little bit of setup.
</p>

<p>
As with <link href="state.html#state.page-properties">specified properties</link>, 
Tapestry will fabricate an enhanced subclass with
the necessary instance variables, accessor methods, and cleanup code.
</p>
	
<p>
Connected parameters are controlled by the direction	
attribute of the &spec.parameter; element.
There are four values:
in, form, auto
and custom.  The default is custom, which
<em>does not</em> create a connected parameter property at all.
</p>

<warning>
	The name, "direction", made sense initially, but is now a bit confusing. It probably
	should have been called "processing" or "connection-type".  In addition, a focus of Tapestry 3.1
  is to remove the direction attribute; all parameters will be accessed through a connected parameter property,
  based on an enhanced implementation of the auto direction.
</warning>

<section id="components.parameters.connected.in">
	<title>Direction: in</title>
	
<p>
The majority of component parameters are read-only, and are only actually used
within the component's <code>renderComponent()</code>	 method ... the method that
actually produces HTML output. For such components, direction in
is the standard, efficient choice.
</p>

<p>
The connected parameter for each component is set just before <code>renderComponent()</code>	
is invoked.  The parameter is reset to its initial value just after 
<code>renderComponent()</code> is invoked.
</p>

<p>
Each component has a &ParameterManager;, whose responsibility is to set and reset connected
parameter properties.	
</p>

<figure alt="ParameterManage and renderComponent()"
  src="&imageroot;/parameter-manager.png"/>
  
      <p>
The &ParameterManager; will read the values bound to each parameter, and update the
connected parameter property before the component's <code>renderComponent()</code>
method is invoked. The &ParameterManager; cleans up after <code>renderComponent()</code>
is invoked.
     </p>


<p>
For invariant bindings (literal strings and such), the &ParameterManager; will only set the connected parameter property once,
and does not reset the property after <code>renderComponent()</code>.
</p>

<warning>
		If your component has any &listener-method;s that need to access a parameter value, then you
		can't use direction in (or direction form).  Listener methods are
		invoked outside of the page rendering process, when value stored in the
		connected parameter property is not set. You must use direction auto or 
		custom in such cases.
</warning>

	
</section> <!-- components.parameters.connected.in -->

<section id="components.parameters.connected.form">
	<title>Direction: form</title>
	
<p>
Components, such as &TextField; or &Checkbox;, that produce form control elements are the
most likely candidates for updating their parameters. The read a parameter (usually named
value) when they render. When the form is submitted, the same components
read a query parameter and update their value parameter.
</p>

<p>
The formdirection simplifies this. For the most part, direction form
is the same as direction in.  The diffference is, when the form is submitted, after the
component's <code>renderComponent()</code> method has been invoked, the connected parameter property
is read and used to update the binding (that is, invoke the binding object's <code>setObject()</code> 
method).
</p>
	
</section> <!-- components.parameters.connected.form -->

<section id="components.parameters.connected.auto">
	<title>Direction: auto</title>
	
<p>
The previous direction values, in and form, have limitations. The value may only be
accessed from within the component's <code>renderComponent()</code> method. That's often insufficient,
especially when the component has a &listener-method; that needs access to a parameter.
</p>

<p>
Direction auto	doesn't use the &ParameterManager;. Instead, the connected parameter property
is <em>synthetic</em>.  Reading the property immediately turns around and invokes
&IBinding;'s <code>getObject()</code> method.  Updating the property invokes
the &IBinding;'s <code>setObject()</code> function.
</p>

<p>
This can be a bit less efficient than direction in, as the &OGNL; expression may be
evaluated multiple times. In Tapestry 3.0, the parameter must also be required. Future releases
of Tapestry will relax these limitations.
</p>

<note>
Parameter directions are a bit of a sore spot: you must make too many decisions about how to use them, especially
in terms of render-time-only vs. &listener-method;. Direction auto	 is too limited and
possibly too inefficient. Tapestry 3.1 will address these limitations by improving direction
auto. Instead of specifying a direction, you'll specify how long the component can cache the
value obtained from the binding object (no caching, or only while the component is rendering, or until
the page finishes rendering). It will soon no longer be necessary to think about or set a parameter direction.
</note>
	
</section> <!-- components.parameters.connected.auto -->	
	
<section id="components.parameters.connected.custom">
	<title>Direction: custom</title>
	
<p>
The custom	 direction, which is the default, <em>does not</em>
create a connected parameter property. Your code is still responsible for
accessing the &IBinding; object (via the <code>getBinding()</code> method of
&IComponent;) and for invoking methods on the binding object.
</p>	


</section> <!-- components.parameters.connected.custom -->	

</section> <!-- components.parameters.connected -->		
		
</section> <!-- components.parameters -->



<section id="components.libraries">
	<title>Component Libraries</title>
	
<p>
Tapestry has a very advanced concept of a <em>component library</em>. A component library contains both Tapestry components and Tapestry pages
(not to mention engine services).
</p>

<section id="components.libraries.ref">
	<title>Referencing Library Components</title>
	
<p>
Before a component library may be used, it must be listed in the application specification. Often, an application specification is <em>only</em>	
needed so that it may list the libraries used by the application. Libraries are identified using the &spec.library; element.
</p>

<p>
The &spec.library; element provides an <em>id</em> for the library, which is used to reference components (and pages) within the library. It also 
provides a path to the library's specification. This is a complete path for a .library file on the classpath. For example:
</p>
<source><![CDATA[
<application name="Example Application">
      
  <library id="contrib" specification-path="/org/apache/tapestry/contrib/Contrib.library"/>
  	
</application>]]></source>

<p>
In this example, Contrib.library defines a set of components, and those component can be accessed using
contrib: as a prefix. In an HTML template, this might appear as:
</p>

<source><![CDATA[	
<span jwcid="palette@contrib:Palette" . . . />
]]></source>


<p>
This example defines a component with id <code>palette</code>. The component will be an instance of the Palette component, supplied within
the contrib component library. If an application uses multiple libraries, they will each have their own prefix. 
Unlike JSPs and JSP tag libraries, the prefix is set once, in the application specification, and is used consistently in all HTML templates and
 specifications within the application.
</p>

<p>
The same syntax may be used in page and component specifications:
</p>

<source><![CDATA[
<component id="palette" type="contrib:Palette">
  . . .
</component>
]]></source>


</section> <!-- components.libraries.ref -->

<section id="components.libraries.search">
	<title>Library component search path</title>
	
<p>
<link href="#components.spec">Previously</link>, we described the search path for components and pages within the application. The rules are somewhat different
for components and pages within a library.
</p>	

<p>
Tapestry searches for library component specifications in the following places:
</p>

<ul>
	<li>
		As specified in a &spec.component-type; element (with the library specification).
	</li>	
	<li>
		In the same package folder as the 
			library specification.
	</li>
</ul>	


<p>
The search for page specifications is identical: as defined in the library specification, or in the same package folder. 	
</p>

</section> <!-- components.libraries.search -->

<section id="components.libraries.private-assets">
	<title>Using Private Assets</title>
	
<p>
Often, a component must be packaged up with images, stylesheets or other resources (collectively termed "assets")
that are needed at runtime. A reference to such an asset can be created using the &spec.private-asset; element of
the page or component specification.	For example:
</p>

<source><![CDATA[
	
  <private-asset name="logo" resource-path="images/logo_200.png"/>
  
  <component id="image" type="Image">
    <binding name="image" expression="assets.logo"/>
  </component>
]]></source>


<p>
All assets (private, context or external) are converted into instances of &IAsset; and treated identically by
components (such as &Image;). As in this example, relative paths are allowed: they are interpreted relative
to the specification (page or component) they appear in.	
</p>

<p>
The Tapestry framework will ensure that an asset will be converted to a valid URL that may be referenced from a client
web browser ... even though the actual service is inside a JAR or otherwise on the classpath, not normally
referenceable from the client browser.
</p>

<p>
The <em>default</em>	behavior is to serve up the <em>localized</em> resource
using the asset service. In effect, the framework will read the contents of the asset and pipe that binary content
down to the client web browser. 
</p>

<p>
An alternate behavior is to have the framework copy the asset to a fixed directory. This directory should be mapped
to a known web folder; that is, have a URL that can be referenced from a client web browser. In this way, the web server
can more efficiently serve up the asset, as a static resource (that just happens to be copied into place in a just-in-time manner).

</p>

<p>
This behavior is controlled by a pair of <link href="configuration.html#configuration.search-path">configuration properties</link>:
org.apache.tapestry.asset.dir and org.apache.tapestry.asset.URL.

</p>	
</section> <!-- components.libraries.private-assets -->

<section id="components.libraries.spec">
	<title>Library Specifications</title>


<p>
A library specification is a file with a .library	 extension. Library specifications
use a root element of &spec.library-specification;, which supports a subset of the attributes
allowed within an &spec.application; element (but allowing the <em>same</em> nested elements). Often, the library specification is an empty placeholder, used
to an establish a search location for page and component specifications:
</p>

<source><![CDATA[
<!DOCTYPE library-specification PUBLIC 
  "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
  "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd">
	
<library-specification/>
]]></source>

	
<p>
It is allowed that components in one library be constructed using components provided by another library. 
The referencing library's specification may contain
&spec.library; elements that identify some other library.	
</p>

</section> <!-- comopnents.libraries.spec -->

<section id="components.libraries.namespace">
	<title>Libraries and Namespaces</title>
	
<p>
Tapestry organizes components and pages (but <em>not</em>	 engine services) into
<em>namespaces</em>. Namespaces are closely related to, but not exactly the same as,
the library prefix established using the &spec.library; element in an application or library specification.
</p>

<p>
Every Tapestry application consists of a default namespace, the application namespace. This is the namespace used 
when referencing a page or component without a prefix. When a page or component can't be resolved within the application namespace,
the framework namespace is searched. Only if the component (or page) is not part of the framework namespace does an error result.	
</p>

<p>
In fact, it is possible to override both pages and components provided by the framework. This is frequently used to change the
look and feel of the default StateSession or Exception page.  In theory, it is even possible to override fundamental components such as
&Insert; or &Foreach;!
</p>

<p>
Every component provides a namespace	 property that defines the namespace (an instance
of &INamespace;) that the component belongs to.
</p>

<p>
You rarely need to be concerned with namespaces, however. The rare exception is when a page from a library wishes to
make use of the &PageLink; or &ExternalLink; components to create a link to <em>another page</em>	 within
the same namespace. This is accomplished (in the source page's HTML template) as:
</p>

<source><![CDATA[
  <a href="#" jwcid="@PageLink" page="OtherPage" namespace="ognl:namespace"> ... </a>]]>	
</source>


</section> <!-- components.libraries.namespace -->
	
</section> <!-- components.libraries -->


</body>
</document>
